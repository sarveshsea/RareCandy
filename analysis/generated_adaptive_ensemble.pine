// Generated by adaptive_online_ensemble.py
// Adaptive Ensemble Strategy (research template)
// Uses online score updates for multiple sub-signals and weighted voting.

//@version=6
strategy("Adaptive Ensemble (Research)", overlay=true, initial_capital=10000, commission_type=strategy.commission.percent, commission_value=0.06, pyramiding=0, calc_on_bar_close=true)

// ===== Inputs =====
decay        = input.float(0.985, "Score Decay", step=0.001)
rewardScale  = input.float(220.0, "Reward Scale", step=1.0)
entryThresh  = input.float(0.16, "Vote Threshold", step=0.01)
killDDPct    = input.float(14.0, "Kill DD %", step=0.1)
stopATRMult  = input.float(2.2, "ATR Stop Mult", step=0.1)

// ===== Module 1: Jurik-like Breakout =====
jLen = input.int(9, "Jurik Length")
pivL = input.int(4, "Pivot Length")
phase = 0.1
beta = 0.45 * (jLen - 1) / (0.45 * (jLen - 1) + 2)
alpha = math.pow(beta, phase)
var float jma = na
jma := na(jma[1]) ? close : (1 - alpha) * close + alpha * jma[1]
trendJ = jma >= jma[3]
ph = ta.pivothigh(high, pivL, pivL)
pl = ta.pivotlow(low, pivL, pivL)
atr200 = ta.atr(200)
var float H = na
var int Hi = 0
var int brkUp = 0
var float L = na
var int Li = 0
var int brkDn = 0
var float upperLvl = na
var float lowerLvl = na
var bool upperOn = false
var bool lowerOn = false
if trendJ != trendJ[1]
    upperOn := false
    lowerOn := false
if trendJ and not upperOn and not na(ph) and Hi > brkUp and not na(H) and math.abs(ph - H) < atr200
    upperOn := true
    upperLvl := ph
if trendJ and not na(ph)
    H := ph
    Hi := bar_index - pivL
m1Long = upperOn and close > upperLvl
if m1Long
    upperOn := false
    brkUp := bar_index
if not trendJ and not lowerOn and not na(pl) and Li > brkDn and not na(L) and math.abs(pl - L) < atr200
    lowerOn := true
    lowerLvl := pl
if not trendJ and not na(pl)
    L := pl
    Li := bar_index - pivL
m1Short = lowerOn and close < lowerLvl
if m1Short
    lowerOn := false
    brkDn := bar_index
var int m1Pos = 0
m1Pos := m1Long ? 1 : m1Short ? -1 : nz(m1Pos[1], 0)

// ===== Module 2: Extreme HMA ATR =====
lenH = input.int(33, "Extreme HMA Length")
atrMulH = input.float(0.7, "Extreme HMA ATR Mult", step=0.05)
sqrtlen = math.round(math.sqrt(lenH))
halflen = math.round(lenH / 2)
hma = ta.ema(close, sqrtlen)
h = ta.highest(hma, lenH)
l = ta.lowest(hma, lenH)
hh = ta.lowest(h, halflen)
ll = ta.highest(l, halflen)
mid = (hh + ll) / 2
atrH = ta.atr(30) * atrMulH
upH = mid + atrH
dnH = mid - atrH
Lh = close > upH
Sh = close < dnH
var int m2Pos = 0
if Lh
    m2Pos := 1
else if Sh
    m2Pos := -1
else
    m2Pos := nz(m2Pos[1], 0)

// ===== Module 3: GK Ribbon =====
lenGK = input.int(70, "GK Length")
multGK = input.float(1.2, "GK ATR Mult", step=0.1)
lag = math.max(int(math.floor((lenGK - 1) / 2)), 0)
zl = ta.ema(lag > 0 ? close + (close - close[lag]) : close, lenGK)
atrGK = ta.atr(14)
upGK = zl + atrGK * multGK
dnGK = zl - atrGK * multGK
bullGK = (close > upGK and close[1] > upGK[1] and close[2] > upGK[2]) and zl > zl[1]
bearGK = (close < dnGK and close[1] < dnGK[1] and close[2] < dnGK[2]) and zl < zl[1]
var int trGK = 0
trGK := bullGK ? 1 : bearGK ? -1 : nz(trGK[1], 0)
var int m3Pos = 0
if trGK != trGK[1] and trGK != 0
    m3Pos := trGK
else
    m3Pos := nz(m3Pos[1], 0)

// ===== Online scoring =====
ret = close[1] != 0 ? (close / close[1] - 1.0) : 0.0
var float s1 = 0.0
var float s2 = 0.0
var float s3 = 0.0
s1 := nz(s1[1]) * decay + (nz(m1Pos[1]) * ret) * rewardScale
s2 := nz(s2[1]) * decay + (nz(m2Pos[1]) * ret) * rewardScale
s3 := nz(s3[1]) * decay + (nz(m3Pos[1]) * ret) * rewardScale

w1 = math.max(s1, 0)
w2 = math.max(s2, 0)
w3 = math.max(s3, 0)
wd = w1 + w2 + w3
vote = wd > 0 ? (w1 * m1Pos + w2 * m2Pos + w3 * m3Pos) / wd : 0

wantLong  = vote > entryThresh
wantShort = vote < -entryThresh

// ===== Risk control =====
atrRisk = ta.atr(14)
longStop = close - atrRisk * stopATRMult
shortStop = close + atrRisk * stopATRMult

var float eqPeak = na
eqPeak := na(eqPeak) ? strategy.equity : math.max(eqPeak, strategy.equity)
ddPct = eqPeak > 0 ? (1 - strategy.equity / eqPeak) * 100 : 0
kill = ddPct > killDDPct

if kill
    strategy.close_all("DD kill")
else
    if wantLong and strategy.position_size <= 0
        strategy.entry("L", strategy.long)
    if wantShort and strategy.position_size >= 0
        strategy.entry("S", strategy.short)

if strategy.position_size > 0
    strategy.exit("Lx", "L", stop=longStop)
if strategy.position_size < 0
    strategy.exit("Sx", "S", stop=shortStop)

plot(vote, "Ensemble Vote", color=color.new(color.aqua, 0), linewidth=2, display=display.pane)
plot(0, "Zero", color=color.new(color.gray, 70), display=display.pane)
plot(zl, "GK Base", color=trGK == 1 ? color.lime : trGK == -1 ? color.red : color.gray)
