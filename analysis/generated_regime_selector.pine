// Generated by adaptive_regime_selector.py
// Adaptive Regime Selector (research template)
//@version=6
strategy("Adaptive Regime Selector (Research)", overlay=true, initial_capital=10000, commission_type=strategy.commission.percent, commission_value=0.06, pyramiding=0, calc_on_bar_close=true)

// Tuned defaults from offline search
decay          = input.float(0.99, "Score Decay", step=0.001)
rewardScale    = input.float(120.0, "Reward Scale", step=1.0)
voteThreshold  = input.float(0.28, "Vote Threshold", step=0.01)
ddKillPct      = input.float(8.0, "DD Kill %", step=0.1)
cooldownBars   = input.int(48, "Cooldown Bars", minval=1)
targetBarVol   = input.float(0.0025, "Target Bar Vol", step=0.0001)
maxLeverage    = input.float(1.2, "Max Leverage", step=0.1)
allowShort     = input.bool(false, "Allow Shorts")

// --- Expert 1: Jurik breakout (compact approximation)
jLen = input.int(9, "Jurik Len")
phase = 0.1
beta = 0.45 * (jLen - 1) / (0.45 * (jLen - 1) + 2)
alpha = math.pow(beta, phase)
var float jma = na
jma := na(jma[1]) ? close : (1 - alpha) * close + alpha * jma[1]
jTrend = jma >= jma[3]
e1 = jTrend ? 1.0 : -1.0

// --- Expert 2: GK ribbon trend
lenGK = input.int(70, "GK Len")
multGK = input.float(1.2, "GK Mult", step=0.1)
lag = math.max(int(math.floor((lenGK - 1) / 2)), 0)
zl = ta.ema(lag > 0 ? close + (close - close[lag]) : close, lenGK)
atrGK = ta.atr(14)
upGK = zl + atrGK * multGK
dnGK = zl - atrGK * multGK
bullGK = (close > upGK and close[1] > upGK[1] and close[2] > upGK[2]) and zl > zl[1]
bearGK = (close < dnGK and close[1] < dnGK[1] and close[2] < dnGK[2]) and zl < zl[1]
var float e2 = 0.0
if bullGK
    e2 := 1.0
else if bearGK
    e2 := -1.0

// --- Expert 3: volume-skew style oscillator sign
sk = ta.ema(close - ta.vwma(close, 100), 5)
e3 = sk > 0 ? 1.0 : -1.0

// --- Expert 4: DAFE-style bandwidth/position composite
basis = ta.sma(close, 20)
dev = ta.stdev(close, 20)
upper = basis + 2.0 * dev
lower = basis - 2.0 * dev
pctb = (close - lower) / math.max(upper - lower, syminfo.mintick)
e4 = pctb > 0.55 ? 1.0 : pctb < 0.45 ? -1.0 : 0.0

// Macro regime proxy (BOS-like): risk score from broad market internals.
// In Pine we approximate with BTC, ETH, DXY, VIX direction spreads.
btcUp = request.security("COINBASE:BTCUSD", timeframe.period, close > ta.ema(close, 50) ? 1 : 0)
ethUp = request.security("COINBASE:ETHUSD", timeframe.period, close > ta.ema(close, 50) ? 1 : 0)
dxyUp = request.security("TVC:DXY", timeframe.period, close > ta.ema(close, 50) ? 1 : 0)
vixUp = request.security("TVC:VIX", timeframe.period, close > ta.ema(close, 50) ? 1 : 0)
riskScore = (btcUp + ethUp) - (dxyUp + vixUp)

// Online expert scoring
ret = close[1] != 0 ? (close / close[1] - 1.0) : 0.0
var float s1 = 0.0
var float s2 = 0.0
var float s3 = 0.0
var float s4 = 0.0
s1 := nz(s1[1]) * decay + (nz(e1[1]) * ret) * rewardScale
s2 := nz(s2[1]) * decay + (nz(e2[1]) * ret) * rewardScale
s3 := nz(s3[1]) * decay + (nz(e3[1]) * ret) * rewardScale
s4 := nz(s4[1]) * decay + (nz(e4[1]) * ret) * rewardScale

ema200 = ta.ema(close, 200)

float vote = 0.0
if riskScore >= 1
    // risk-on pool: e1,e2,e4
    w1 = math.max(s1, 0), w2 = math.max(s2, 0), w4 = math.max(s4, 0)
    den = w1 + w2 + w4
    vote := den > 0 ? (w1 * e1 + w2 * e2 + w4 * e4) / den : 0
else if riskScore <= -1
    // risk-off pool: e2,e3,e4
    w2 = math.max(s2, 0), w3 = math.max(s3, 0), w4 = math.max(s4, 0)
    den = w2 + w3 + w4
    vote := den > 0 ? (w2 * e2 + w3 * e3 + w4 * e4) / den : 0
else
    // neutral: trend-follow only when above EMA200
    if close > ema200
        w1 = math.max(s1, 0), w2 = math.max(s2, 0)
        den = w1 + w2
        vote := den > 0 ? (w1 * e1 + w2 * e2) / den : 0
    else
        vote := 0

wantLong = vote > voteThreshold
wantShort = allowShort and vote < -voteThreshold

// Trend gate
if close < ema200 and wantLong
    wantLong := false
if close > ema200 and wantShort
    wantShort := false

// Vol target leverage approximation
rv = ta.stdev(math.log(close / close[1]), 96)
lev = rv > 0 ? math.min(maxLeverage, targetBarVol / rv) : 1.0

// DD kill-switch
var float eqPeak = na
eqPeak := na(eqPeak) ? strategy.equity : math.max(eqPeak, strategy.equity)
ddPct = eqPeak > 0 ? (1 - strategy.equity / eqPeak) * 100 : 0
var int cool = 0
if ddPct > ddKillPct and cool == 0
    cool := cooldownBars
if cool > 0
    cool -= 1

if cool > 0
    strategy.close_all("DD Kill")
else
    if wantLong and strategy.position_size <= 0
        strategy.entry("L", strategy.long, qty=lev)
    if wantShort and strategy.position_size >= 0
        strategy.entry("S", strategy.short, qty=lev)
    if not wantLong and strategy.position_size > 0
        strategy.close("L")
    if not wantShort and strategy.position_size < 0
        strategy.close("S")

plot(vote, "Vote", color=color.aqua, linewidth=2, display=display.pane)
plot(0, "Zero", color=color.new(color.gray, 70), display=display.pane)
